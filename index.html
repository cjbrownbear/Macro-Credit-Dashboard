<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Macro–Credit Stress Dashboard</title>
  <style>
    :root{
      --bg0:#060a12;
      --bg1:#0a1020;
      --card:#0b1224cc;
      --card2:#0b1224aa;
      --border:#2b3550aa;
      --text:#e7ecf6;
      --muted:#b8c0d6;
      --muted2:#7f8aa8;
      --good:#22c55e;
      --watch:#fbbf24;
      --bad:#ef4444;
      --shadow: 0 24px 80px rgba(0,0,0,.55);
      --radius: 18px;
      --radius2: 14px;
    }

    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 15% 25%, rgba(59,130,246,.28), transparent 60%),
        radial-gradient(1100px 900px at 85% 70%, rgba(16,185,129,.18), transparent 55%),
        radial-gradient(900px 700px at 55% 15%, rgba(244,63,94,.12), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap{max-width:1160px; margin:0 auto; padding:34px 18px 60px;}
    h1{margin:0 0 8px; font-size:40px; letter-spacing:-0.02em;}
    p{margin:0}
    .sub{
      color:var(--muted);
      max-width:980px;
      line-height:1.45;
      font-size:14px;
    }
    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      margin-bottom:18px;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(10,16,32,.55);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      font-weight:650;
      letter-spacing:0.01em;
      font-size:13px;
      white-space:nowrap;
    }
    .badge-dot{width:8px; height:8px; border-radius:999px; background:var(--good)}
    .badge.watch .badge-dot{background:var(--watch)}
    .badge.bad .badge-dot{background:var(--bad)}

    .statusSummary{
      margin-top:10px;
      color:var(--muted);
      font-size:14px;
      line-height:1.5;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(10,16,32,.35);
      max-width:980px;
    }

    .sectionTitle{
      margin:26px 0 10px;
      font-size:18px;
      font-weight:750;
      letter-spacing:-0.01em;
    }

    .cards{
      display:grid;
      grid-template-columns:repeat(2, minmax(0,1fr));
      gap:14px;
    }
    @media (max-width: 900px){
      .cards{grid-template-columns:1fr;}
      h1{font-size:34px;}
    }

    .card{
      border-radius:var(--radius);
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(14,22,44,.66), rgba(10,16,32,.40));
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .cardPad{padding:14px 14px 12px;}

    /* News */
    .newsHead{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .newsTitle{
      font-weight:800;
      font-size:14px;
      letter-spacing:-0.01em;
    }
    .newsMeta{
      color:var(--muted2);
      font-size:12px;
    }
    .newsList{
      list-style:none;
      margin:0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .newsList a{
      color:var(--text);
      text-decoration:none;
      font-size:13px;
      line-height:1.35;
      display:block;
    }
    .newsList a:hover{text-decoration:underline}
    .newsItemMeta{
      color:var(--muted2);
      font-size:11px;
      margin-top:2px;
    }

    /* Legend chips */
    .legend{
      display:flex;
      gap:10px;
      margin:14px 0 0;
      align-items:center;
      flex-wrap:wrap;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:5px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid var(--border);
      background:rgba(10,16,32,.35);
      color:var(--muted);
    }
    .chipDot{width:8px; height:8px; border-radius:999px;}
    .chip.good{color:var(--good); border-color:rgba(34,197,94,.35)}
    .chip.good .chipDot{background:var(--good)}
    .chip.watch{color:var(--watch); border-color:rgba(251,191,36,.35)}
    .chip.watch .chipDot{background:var(--watch)}
    .chip.bad{color:var(--bad); border-color:rgba(239,68,68,.35)}
    .chip.bad .chipDot{background:var(--bad)}

    /* KPI tiles */
    .kpiGrid{
      display:grid;
      grid-template-columns:repeat(4, minmax(0,1fr));
      gap:14px;
    }
    @media (max-width: 1100px){
      .kpiGrid{grid-template-columns:repeat(2, minmax(0,1fr));}
    }
    .kpi{
      position:relative;
      padding:14px 14px 12px;
      border-radius:var(--radius);
      border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(14,22,44,.70), rgba(10,16,32,.45));
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height:140px;
    }
    .kpiTitle{
      font-size:14px;
      font-weight:800;
      letter-spacing:-0.01em;
      margin:0 0 2px;
      padding-right:86px; /* room for status pill */
    }
    .kpiSub{
      color:var(--muted2);
      font-size:12px;
      margin:0;
      line-height:1.2;
    }
    .kpiValue{
      margin-top:10px;
      font-size:30px;
      font-weight:850;
      letter-spacing:-0.02em;
    }
    .kpiMetaRow{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:4px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:12px;
    }
    .kpiDelta{
      margin-top:8px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .kpiDelta .pos{color:var(--text)}
    .kpiDelta .neg{color:var(--text)}
    .kpiSpark{
      margin-top:8px;
      width:100%;
      height:34px;
      opacity:.95;
    }

    .pill{
      position:absolute;
      top:12px;
      right:12px;
      padding:5px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:750;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.20);
    }
    .pill.good{color:var(--good); border-color:rgba(34,197,94,.35)}
    .pill.watch{color:var(--watch); border-color:rgba(251,191,36,.35)}
    .pill.bad{color:var(--bad); border-color:rgba(239,68,68,.35)}

    /* Charts */
    .trendControls{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin:0 0 12px;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:13px;
    }
    .toggle input{transform:scale(1.1)}
    .help{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:18px; height:18px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted2);
      font-size:12px;
      cursor:default;
    }
    .chartsGrid{
      display:grid;
      grid-template-columns:repeat(2, minmax(0,1fr));
      gap:14px;
    }
    @media (max-width: 900px){
      .chartsGrid{grid-template-columns:1fr;}
    }

    .chartCard{padding:14px 14px 12px;}
    .chartHead{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      margin-bottom:4px;
    }
    .chartTitle{
      font-size:14px;
      font-weight:850;
      letter-spacing:-0.01em;
      margin:0;
    }
    .chartMeta{
      font-size:12px;
      color:var(--muted2);
      white-space:nowrap;
    }
    .chartDef{
      color:var(--muted);
      font-size:12.5px;
      line-height:1.35;
      margin:4px 0 8px;
    }
    .chartSummary{
      color:var(--muted);
      font-size:12.5px;
      line-height:1.35;
      margin:0 0 10px;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      border-radius:12px;
    }

    .canvasWrap{
      height:270px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      overflow:hidden;
      position:relative;
    }
    canvas{display:block; width:100%; height:100%}

    .footer{
      margin-top:18px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(10,16,32,.38);
      color:var(--text);
      text-decoration:none;
      font-weight:700;
      font-size:13px;
    }
    .btn:hover{background:rgba(10,16,32,.55)}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>Macro–Credit Stress Dashboard</h1>
        <p class="sub">
          A lightweight read on household stress and labor softening, built from public series that tend to move early:
          <b>card delinquencies</b>, <b>charge-offs</b>, <b>debt service burden</b>, <b>mortgage delinquencies</b>,
          and <b>labor</b> signals. Tiles show the latest value, a 10-year baseline, and the 1-year change
          (with clear units). Charts below show the full trend with hover-to-inspect values.
          (<span id="lastUpdated">Last updated: —</span>)
        </p>
        <div id="statusSummary" class="statusSummary" style="display:none;"></div>
      </div>
      <div id="overallBadge" class="badge">
        <span class="badge-dot"></span>
        <span id="overallText">Overall: —</span>
      </div>
    </div>

    <div class="sectionTitle">Latest headlines</div>
    <div class="cards">
      <div class="card">
        <div class="cardPad">
          <div class="newsHead">
            <div class="newsTitle" id="newsLeftTitle">Credit / consumer stress</div>
            <div class="newsMeta">auto-updated</div>
          </div>
          <ul class="newsList" id="newsLeft"></ul>
        </div>
      </div>
      <div class="card">
        <div class="cardPad">
          <div class="newsHead">
            <div class="newsTitle" id="newsRightTitle">Labor / macro signals</div>
            <div class="newsMeta">auto-updated</div>
          </div>
          <ul class="newsList" id="newsRight"></ul>
        </div>
      </div>
    </div>

    <div class="legend" aria-label="Legend">
      <span class="chip good"><span class="chipDot"></span>Healthy</span>
      <span class="chip watch"><span class="chipDot"></span>Tripwire / Watch</span>
      <span class="chip bad"><span class="chipDot"></span>Stress</span>
    </div>

    <div class="sectionTitle">Latest snapshot</div>
    <div class="kpiGrid" id="kpiGrid"></div>

    <div class="sectionTitle">Trends (interactive)</div>
    <div class="trendControls">
      <div class="toggle">
        <label style="display:flex; align-items:center; gap:10px;">
          <input id="normToggle" type="checkbox" />
          Normalize charts (Index=100 at 10-year average)
        </label>
        <span class="help" title="When enabled, each series is indexed to its 10-year average (100). This makes cross-series shapes comparable even when units differ. Benchmarks and moving averages are shown in indexed space.">?</span>
      </div>
      <div class="toggle" style="color:var(--muted2);">
        Benchmarks: dotted = 10y avg; dashed = tripwire/stress; thin dash = moving avg
      </div>
    </div>

    <div class="chartsGrid" id="chartsGrid"></div>

    <div class="footer">
      <a class="btn" href="./data.json" download>Download data.json</a>
      <a class="btn" href="./news.json" download>Download news.json</a>
      <a class="btn" href="./macro_credit_timeseries.xlsx" download>Download Excel (metrics + timeseries)</a>
      <a class="btn" href="./macro_credit_metrics.xlsx" download>Download Excel (metrics)</a>
    </div>
  </div>

  <script>
    const KPI_ORDER = [
      // Row 1
      "DRCCLACBS_pct",
      "CORCCACBS_pct",
      "TDSP_pct",
      "DRSFRMACBS_pct",
      // Row 2
      "REVOLSL_bil_usd",
      "JTSJOL_mil",
      "UNRATE_pct",
      "ICSA_thou",
    ];

    // Trend chart cards (you can add non-KPI series here)
    const CHART_DEFS = [
      { key:"DRCCLACBS_pct" },
      { key:"CORCCACBS_pct" },
      { key:"TDSP_pct" },
      // Mortgage delinquency with a leading housing overlay (permits)
      { key:"DRSFRMACBS_pct", secondary:"PERMIT_thou_units", secondaryLabel:"Building Permits (PERMIT)" },

      // Revolving credit with income overlay
      { key:"REVOLSL_bil_usd", secondary:"DSPIC96_bil_usd", secondaryLabel:"Real Disposable Income (DSPIC96)" },
      { key:"JTSJOL_mil" },
      { key:"UNRATE_pct" },
      { key:"ICSA_thou" },

      // Extra housing cycle chart (not a KPI)
      { key:"CSUSHPINSA_index", secondary:"PERMIT_thou_units", secondaryLabel:"Building Permits (PERMIT)" },
    ];

    const $ = (id) => document.getElementById(id);

    function statusToClass(s){
      if (s === "stress") return "bad";
      if (s === "tripwire") return "watch";
      return "good";
    }

    function fmtNum(x, decimals=0){
      if (x === null || x === undefined) return "—";
      const n = Number(x);
      if (!Number.isFinite(n)) return "—";
      return n.toLocaleString(undefined, {minimumFractionDigits:decimals, maximumFractionDigits:decimals});
    }

    function fmtValue(v, units){
      if (v === null || v === undefined) return "—";
      const n = Number(v);
      if (!Number.isFinite(n)) return "—";
      if (units === "pct") return fmtNum(n, 2) + "%";
      if (units === "mil") return fmtNum(n, 2).replace(/\.00$/,"") + "M";
      if (units === "thou") return fmtNum(n, 0) + "K";
      if (units === "usd_b") return "$" + fmtNum(n, 0) + "B";
      if (units === "index") return fmtNum(n, 1);
      return fmtNum(n, 2);
    }

    function fmtDeltaAbs(d, units){
      if (d === null || d === undefined) return "—";
      const n = Number(d);
      if (!Number.isFinite(n)) return "—";
      const sign = n > 0 ? "+" : n < 0 ? "−" : "";
      const abs = Math.abs(n);
      if (units === "pct") return sign + fmtNum(abs, 2) + "pp";
      if (units === "mil") return sign + fmtNum(abs, 2).replace(/\.00$/,"") + "M";
      if (units === "thou") return sign + fmtNum(abs, 0) + "K";
      if (units === "usd_b") return sign + "$" + fmtNum(abs, 0) + "B";
      if (units === "index") return sign + fmtNum(abs, 1);
      return sign + fmtNum(abs, 2);
    }

    function fmtDeltaPct(d){
      if (d === null || d === undefined) return "—";
      const n = Number(d);
      if (!Number.isFinite(n)) return "—";
      const sign = n > 0 ? "+" : n < 0 ? "−" : "";
      return sign + fmtNum(Math.abs(n), 1) + "%";
    }

    function makePill(status){
      const cls = statusToClass(status);
      const label = status === "stress" ? "Stress" : status === "tripwire" ? "Tripwire" : "Healthy";
      return `<span class="pill ${cls}">${label}</span>`;
    }

    function seriesToPoints(rows, key){
      const pts = [];
      for (const r of rows){
        const v = r[key];
        if (v === null || v === undefined) continue;
        const n = Number(v);
        if (!Number.isFinite(n)) continue;
        pts.push({ t: new Date(r.date + "T00:00:00Z"), v: n });
      }
      return pts;
    }

    function movingAverage(values, window){
      if (window <= 1) return values.map(v => v);
      const out = [];
      let sum = 0;
      const q = [];
      for (const v of values){
        q.push(v);
        sum += v;
        if (q.length > window) sum -= q.shift();
        out.push(sum / q.length);
      }
      return out;
    }

    function drawLine(ctx, xs, ys, opts={}){
      const {dash=[], alpha=1, width=2} = opts;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = width;
      ctx.setLineDash(dash);
      ctx.beginPath();
      for (let i=0;i<xs.length;i++){
        const x = xs[i], y = ys[i];
        if (i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function buildChart(canvas, pointsA, pointsB, metaA, metaB, normalize){
      const ctx = canvas.getContext("2d");

      // Cache device sizes
      function resize(){
        const w = canvas.width = canvas.clientWidth * devicePixelRatio;
        const h = canvas.height = canvas.clientHeight * devicePixelRatio;
        return {w,h};
      }

      // Padding
      const padL = 12 * devicePixelRatio;
      const padR = 10 * devicePixelRatio;
      const padT = 12 * devicePixelRatio;
      const padB = 14 * devicePixelRatio;

      const ptsA = (pointsA || []).slice();
      const ptsB = (pointsB || []).slice();

      function roundRect(ctx, x, y, w, h, r){
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();
      }

      function renderBase(hoverIdx=-1){
        const {w,h} = resize();
        ctx.clearRect(0,0,w,h);

        if (ptsA.length < 2){
          ctx.fillStyle = "rgba(184,192,214,.85)";
          ctx.font = `${13*devicePixelRatio}px system-ui`;
          ctx.fillText("No data available.", padL, padT + 16*devicePixelRatio);
          return;
        }

        // Domain from primary series
        const t0 = ptsA[0].t.getTime();
        const t1 = ptsA[ptsA.length-1].t.getTime();

        function normPoint(p, meta){
          const base = (meta && meta.avg_10y !== null && meta.avg_10y !== undefined && Number.isFinite(meta.avg_10y))
            ? Number(meta.avg_10y)
            : ptsA[0].v;
          if (!Number.isFinite(base) || base === 0) return p.v;
          return (p.v / base) * 100.0;
        }

        const ysA_raw = ptsA.map(p => p.v);
        const ysB_raw = ptsB.map(p => p.v);

        const ysA = normalize ? ptsA.map(p => normPoint(p, metaA)) : ysA_raw;
        const ysB = (normalize && ptsB.length) ? ptsB.map(p => normPoint(p, metaB || metaA)) : ysB_raw;

        // Moving average window by cadence
        const maWin = (metaA && metaA.freq === "weekly") ? 13 : (metaA && metaA.freq === "monthly") ? 6 : 4;
        const ysA_ma = movingAverage(ysA, maWin);

        // y-scale
        const allY = ysB.length ? ysA.concat(ysB) : ysA.slice();
        const yMin = Math.min(...allY);
        const yMax = Math.max(...allY);
        const pad = (yMax - yMin) * 0.12 || 1;
        const ymin = yMin - pad;
        const ymax = yMax + pad;

        const x = (t) => {
          const tt = t.getTime();
          return padL + ( (tt - t0) / (t1 - t0) ) * (w - padL - padR);
        };
        const y = (v) => padT + (1 - (v - ymin) / (ymax - ymin)) * (h - padT - padB);

        // Background
        ctx.fillStyle = "rgba(0,0,0,.12)";
        ctx.fillRect(0,0,w,h);

        // Grid lines
        ctx.strokeStyle = "rgba(255,255,255,.06)";
        ctx.lineWidth = 1 * devicePixelRatio;
        ctx.setLineDash([]);
        for (let i=0;i<=4;i++){
          const yy = padT + i * (h - padT - padB) / 4;
          ctx.beginPath(); ctx.moveTo(padL, yy); ctx.lineTo(w - padR, yy); ctx.stroke();
        }

        // Benchmarks from primary series meta
        if (metaA && metaA.avg_10y !== null && metaA.sd_10y !== null && Number.isFinite(metaA.avg_10y) && Number.isFinite(metaA.sd_10y)){
          const base = normalize ? 100.0 : Number(metaA.avg_10y);
          const sd = Number(metaA.sd_10y);
          const sdEff = normalize ? (sd / Number(metaA.avg_10y)) * 100.0 : sd;
          const trip = base + metaA.direction * sdEff;
          const stress = base + metaA.direction * 2 * sdEff;

          // Mean dotted
          ctx.strokeStyle = "rgba(184,192,214,.55)";
          drawLine(ctx, [padL, w-padR], [y(base), y(base)], {dash:[2*devicePixelRatio, 5*devicePixelRatio], alpha:1, width:1.2*devicePixelRatio});

          // Tripwire dashed
          ctx.strokeStyle = "rgba(251,191,36,.60)";
          drawLine(ctx, [padL, w-padR], [y(trip), y(trip)], {dash:[7*devicePixelRatio, 6*devicePixelRatio], alpha:1, width:1.1*devicePixelRatio});

          // Stress dashed
          ctx.strokeStyle = "rgba(239,68,68,.55)";
          drawLine(ctx, [padL, w-padR], [y(stress), y(stress)], {dash:[10*devicePixelRatio, 6*devicePixelRatio], alpha:1, width:1.1*devicePixelRatio});
        }

        // Primary series
        const xsA = ptsA.map(p => x(p.t));
        const ysA_px = ysA.map(v => y(v));
        ctx.strokeStyle = "rgba(231,236,246,.95)";
        drawLine(ctx, xsA, ysA_px, {dash:[], alpha:1, width:2.2*devicePixelRatio});

        // Moving average
        const ysA_ma_px = ysA_ma.map(v => y(v));
        ctx.strokeStyle = "rgba(184,192,214,.55)";
        drawLine(ctx, xsA, ysA_ma_px, {dash:[4*devicePixelRatio, 6*devicePixelRatio], alpha:1, width:1.4*devicePixelRatio});

        // Secondary overlay
        if (ptsB.length >= 2){
          const xsB = ptsB.map(p => x(p.t));
          const ysB_px = ysB.map(v => y(v));
          ctx.strokeStyle = "rgba(96,165,250,.65)";
          drawLine(ctx, xsB, ysB_px, {dash:[], alpha:1, width:1.8*devicePixelRatio});
        }

        // Hover overlay
        if (hoverIdx >= 0){
          const hx = xsA[hoverIdx];
          const hv = ysA[hoverIdx];
          const hy = y(hv);

          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,.14)";
          ctx.lineWidth = 1 * devicePixelRatio;
          ctx.setLineDash([4*devicePixelRatio, 6*devicePixelRatio]);
          ctx.beginPath();
          ctx.moveTo(hx, padT);
          ctx.lineTo(hx, h - padB);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = "rgba(231,236,246,.95)";
          ctx.beginPath();
          ctx.arc(hx, hy, 3.2*devicePixelRatio, 0, Math.PI*2);
          ctx.fill();

          const dateStr = ptsA[hoverIdx].t.toISOString().slice(0,10);
          const rawA = ysA_raw[hoverIdx];
          const txtA = normalize ? `${fmtValue(rawA, metaA.units)}  (idx ${fmtNum(hv,1)})` : fmtValue(rawA, metaA.units);

          let txtB = "";
          if (ptsB.length){
            const t = ptsA[hoverIdx].t.getTime();
            let bi = 0, bd = Infinity;
            for (let i=0;i<ptsB.length;i++){
              const d = Math.abs(ptsB[i].t.getTime() - t);
              if (d < bd){ bd = d; bi = i; }
            }
            const bRaw = ptsB[bi].v;
            const baseB = (normalize && metaB && metaB.avg_10y !== null && metaB.avg_10y !== undefined && Number.isFinite(metaB.avg_10y))
              ? Number(metaB.avg_10y)
              : (ptsB[0] ? ptsB[0].v : bRaw);
            const bVal = normalize && baseB ? (bRaw / baseB) * 100.0 : bRaw;
            const labelB = metaB && metaB.title ? metaB.title : "Overlay";
            txtB = normalize
              ? `\n${labelB}: ${fmtValue(bRaw, (metaB && metaB.units) ? metaB.units : "index")}  (idx ${fmtNum(bVal,1)})`
              : `\n${labelB}: ${fmtValue(bRaw, (metaB && metaB.units) ? metaB.units : "index")}`;
          }

          const text = `${dateStr}\n${metaA.title}: ${txtA}${txtB}`;
          ctx.font = `${12*devicePixelRatio}px system-ui`;
          const lines = text.split("\n");
          const lineH = 15*devicePixelRatio;
          const padBox = 10*devicePixelRatio;
          const tw = Math.max(...lines.map(l => ctx.measureText(l).width));
          const th = lines.length * lineH + padBox;

          let bx = hx + 10*devicePixelRatio;
          let by = padT + 8*devicePixelRatio;
          if (bx + tw + 2*padBox > w - padR) bx = hx - (tw + 2*padBox + 10*devicePixelRatio);

          ctx.fillStyle = "rgba(0,0,0,.70)";
          ctx.strokeStyle = "rgba(255,255,255,.16)";
          ctx.lineWidth = 1 * devicePixelRatio;
          roundRect(ctx, bx, by, tw + 2*padBox, th, 10*devicePixelRatio);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = "rgba(231,236,246,.95)";
          for (let i=0;i<lines.length;i++){
            ctx.fillText(lines[i], bx + padBox, by + padBox + (i+1)*lineH - 4*devicePixelRatio);
          }
          ctx.restore();
        }
      }

      // Initial render
      let hoverIdx = -1;
      renderBase(-1);

      // Bind hover
      canvas.onmousemove = (ev) => {
        if (ptsA.length < 2) return;
        const rect = canvas.getBoundingClientRect();
        const mx = (ev.clientX - rect.left) * devicePixelRatio;

        // Find nearest x in primary
        const w = canvas.clientWidth * devicePixelRatio;
        const t0 = ptsA[0].t.getTime();
        const t1 = ptsA[ptsA.length-1].t.getTime();
        const x = (t) => {
          const tt = t.getTime();
          return padL + ( (tt - t0) / (t1 - t0) ) * (w - padL - padR);
        };
        const xsA = ptsA.map(p => x(p.t));

        let best = 0, bestDist = Infinity;
        for (let i=0;i<xsA.length;i++){
          const d = Math.abs(xsA[i] - mx);
          if (d < bestDist){ bestDist = d; best = i; }
        }
        hoverIdx = best;
        renderBase(hoverIdx);
      };

      canvas.onmouseleave = () => {
        hoverIdx = -1;
        renderBase(-1);
      };
    }

    function renderNews(news){
      const b = (news && news.buckets) ? news.buckets : {};
      const left = b.credit_consumer || {title:"Credit / consumer stress", items:[]};
      const right = b.labor_macro || {title:"Labor / macro signals", items:[]};

      $("newsLeftTitle").textContent = left.title || "Credit / consumer stress";
      $("newsRightTitle").textContent = right.title || "Labor / macro signals";

      function renderList(el, items){
        el.innerHTML = "";
        if (!items || !items.length){
          el.innerHTML = `<li style="color:var(--muted); font-size:13px;">No headlines available.</li>`;
          return;
        }
        for (const it of items){
          const title = it.title || "Untitled";
          const link = it.link || "#";
          const source = it.source || "";
          const published = it.published || "";
          const li = document.createElement("li");
          li.innerHTML = `
            <a href="${link}" target="_blank" rel="noopener noreferrer">${escapeHtml(title)}</a>
            <div class="newsItemMeta">${escapeHtml(source)}${published ? " · " + escapeHtml(published) : ""}</div>
          `;
          el.appendChild(li);
        }
      }

      renderList($("newsLeft"), left.items);
      renderList($("newsRight"), right.items);
    }

    function escapeHtml(str){
      return String(str).replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m]));
    }

    function renderKPIs(payload){
      const rows = payload.data || [];
      const metrics = payload.metrics || [];
      const byKey = {};
      for (const m of metrics){
        byKey[m.key] = m;
      }

      const grid = $("kpiGrid");
      grid.innerHTML = "";

      for (const key of KPI_ORDER){
        const m = byKey[key];
        if (!m){
          continue;
        }
        const status = m.status || "healthy";
        const units = m.units || "";
        const latestValue = m.latest_value;
        const latestDate = m.latest_date;
        const avg10 = m.avg_10y;
        const deltaAbs = m.delta_1y_abs;
        const deltaPct = m.delta_1y_pct;

        // Sparkline uses last ~36 points
        const pts = seriesToPoints(rows, key);
        const tail = pts.slice(Math.max(0, pts.length - 36));

        const el = document.createElement("div");
        el.className = "kpi";
        el.innerHTML = `
          <div class="kpiTitle">${escapeHtml(m.title || key)}</div>
          <div class="kpiSub">FRED: ${escapeHtml(m.series_id || "")} (${escapeHtml(m.freq || "")}${units === "pct" ? ", %" : units === "mil" ? ", millions" : units === "thou" ? ", thousands" : units === "usd_b" ? ", $B" : units === "index" ? ", index" : ""})</div>
          ${makePill(status)}
          <div class="kpiValue">${fmtValue(latestValue, units)}</div>
          <div class="kpiMetaRow">
            <span>As of: <b>${escapeHtml(latestDate || "—")}</b></span>
            <span>10y avg: <b>${fmtValue(avg10, units)}</b></span>
          </div>
          <canvas class="kpiSpark"></canvas>
          <div class="kpiDelta">
            <span>Change vs year-ago:</span>
            <span class="${(deltaAbs || 0) >= 0 ? "pos" : "neg"}"><b>${fmtDeltaAbs(deltaAbs, units)}</b></span>
            <span>(${fmtDeltaPct(deltaPct)})</span>
          </div>
        `;
        grid.appendChild(el);

        const canvas = el.querySelector("canvas");
        drawSparkline(canvas, tail.map(p => p.v));
      }
    }

    function drawSparkline(canvas, values){
      const ctx = canvas.getContext("2d");
      const w = canvas.width = canvas.clientWidth * devicePixelRatio;
      const h = canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.clearRect(0,0,w,h);
      if (!values || values.length < 2){
        ctx.strokeStyle = "rgba(184,192,214,.35)";
        ctx.beginPath(); ctx.moveTo(6, h/2); ctx.lineTo(w-6, h/2); ctx.stroke();
        return;
      }
      const min = Math.min(...values), max = Math.max(...values);
      const pad = (max-min)*0.12 || 1;
      const ymin = min - pad, ymax = max + pad;
      const x = (i) => (i/(values.length-1))*(w-14*devicePixelRatio) + 7*devicePixelRatio;
      const y = (v) => (1 - (v - ymin)/(ymax-ymin))*(h-10*devicePixelRatio) + 5*devicePixelRatio;

      // line
      ctx.strokeStyle = "rgba(231,236,246,.90)";
      ctx.lineWidth = 2*devicePixelRatio;
      ctx.beginPath();
      for (let i=0;i<values.length;i++){
        const xx=x(i), yy=y(values[i]);
        if (i===0) ctx.moveTo(xx,yy);
        else ctx.lineTo(xx,yy);
      }
      ctx.stroke();
    }

    function renderCharts(payload, normalize){
      const rows = payload.data || [];
      const metrics = payload.metrics || [];
      const byKey = {};
      for (const m of metrics) byKey[m.key] = m;

      const grid = $("chartsGrid");
      grid.innerHTML = "";

      for (const def of CHART_DEFS){
        const m = byKey[def.key];
        if (!m) continue;

        const m2 = def.secondary ? byKey[def.secondary] : null;

        const card = document.createElement("div");
        card.className = "card";
        card.innerHTML = `
          <div class="chartCard">
            <div class="chartHead">
              <h3 class="chartTitle">${escapeHtml(m.title || def.key)}</h3>
              <div class="chartMeta">FRED: ${escapeHtml(m.series_id || "")} (${escapeHtml(m.freq || "")})</div>
            </div>
            <div class="chartDef">${escapeHtml(m.definition || "")}${m2 ? "  •  Overlay: " + escapeHtml(m2.title || def.secondary) : ""}</div>
            <div class="chartSummary">${escapeHtml(m.summary || "—")}</div>
            <div class="canvasWrap"><canvas></canvas></div>
          </div>
        `;
        grid.appendChild(card);

        const canvas = card.querySelector("canvas");
        const ptsA = seriesToPoints(rows, def.key);
        const ptsB = def.secondary ? seriesToPoints(rows, def.secondary) : null;

        // Build the chart
        buildChart(canvas, ptsA, ptsB, m, m2, normalize);
        // Redraw on resize
        const ro = new ResizeObserver(() => buildChart(canvas, ptsA, ptsB, m, m2, normalize));
        ro.observe(canvas.parentElement);
      }
    }

    function renderOverall(payload){
      const meta = payload.meta || {};
      const status = meta.overall_status || "healthy";
      const summary = meta.overall_summary || "";
      const badge = $("overallBadge");
      badge.classList.remove("watch","bad");
      const cls = statusToClass(status);
      if (cls === "watch") badge.classList.add("watch");
      if (cls === "bad") badge.classList.add("bad");
      $("overallText").textContent = `Overall: ${status === "stress" ? "Stress" : status === "tripwire" ? "Tripwire / Watch" : "Healthy"}`;

      const ss = $("statusSummary");
      if (summary){
        ss.style.display = "block";
        ss.textContent = summary;
      }
      if (meta.last_updated_utc){
        $("lastUpdated").textContent = "Last updated: " + meta.last_updated_utc;
      }
    }

    async function main(){
      // normalize toggle persistence
      const normToggle = $("normToggle");
      const normSaved = localStorage.getItem("normCharts") === "1";
      normToggle.checked = normSaved;

      let payload = null;
      let news = null;

      try{
        const r = await fetch("./data.json", {cache:"no-store"});
        payload = await r.json();
      }catch(e){
        console.error("Failed to load data.json", e);
        payload = {meta:{overall_status:"healthy", overall_summary:"Data failed to load."}, data:[], metrics:[]};
      }

      try{
        const r2 = await fetch("./news.json", {cache:"no-store"});
        news = await r2.json();
      }catch(e){
        console.error("Failed to load news.json", e);
        news = {buckets:{}};
      }

      renderOverall(payload);
      renderNews(news);
      renderKPIs(payload);
      renderCharts(payload, normToggle.checked);

      normToggle.onchange = () => {
        localStorage.setItem("normCharts", normToggle.checked ? "1" : "0");
        renderCharts(payload, normToggle.checked);
      };
    }

    main();
  </script>
</body>
</html>
